"use strict";(globalThis.webpackChunkp_foundation=globalThis.webpackChunkp_foundation||[]).push([[2518],{2566:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"security/network","title":"Network Security Measures (OpenIX side)","description":"Network security implementations including MAC filtering, storm control, and access control lists that protect the exchange platform.","source":"@site/OpenIX/06-security/03-network.md","sourceDirName":"06-security","slug":"/security/network","permalink":"/ar/OpenIX/security/network","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"title":"Network Security Measures (OpenIX side)","sidebar_label":"Network Security Measures","description":"Network security implementations including MAC filtering, storm control, and access control lists that protect the exchange platform."},"sidebar":"defaultSidebar","previous":{"title":"Infrastructure Resiliency","permalink":"/ar/OpenIX/security/infrastructure"},"next":{"title":"Participant Responsibilities","permalink":"/ar/OpenIX/security/participantResponsibilities"}}');var n=i(4848),s=i(8453);const o={title:"Network Security Measures (OpenIX side)",sidebar_label:"Network Security Measures",description:"Network security implementations including MAC filtering, storm control, and access control lists that protect the exchange platform."},a=void 0,c={},l=[{value:"MAC Filtering",id:"mac-filtering",level:2},{value:"Storm Control",id:"storm-control",level:2},{value:"Access Control Lists (ACLs)",id:"access-control-lists-acls",level:2},{value:"Route Server Security",id:"route-server-security",level:2},{value:"Monitoring and Anomaly Detection",id:"monitoring-and-anomaly-detection",level:2}];function h(e){const t={h2:"h2",p:"p",strong:"strong",...(0,s.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"OpenIX implements several layers of network security on the exchange:"}),"\n",(0,n.jsx)(t.h2,{id:"mac-filtering",children:"MAC Filtering"}),"\n",(0,n.jsx)(t.p,{children:"As mentioned under technical standards, each port is locked to a specific MAC address. This prevents unknown devices from sending traffic on the exchange even if somehow plugged in. It also stops potential MAC flooding attacks because the switch will not learn beyond the one MAC per port."}),"\n",(0,n.jsx)(t.h2,{id:"storm-control",children:"Storm Control"}),"\n",(0,n.jsx)(t.p,{children:"The exchange switches have broadcast and multicast storm control enabled. This means if a port suddenly starts flooding broadcast traffic above a certain threshold, the switch will suppress it to protect other ports. This helps mitigate issues like accidental broadcast storms from misconfigurations."}),"\n",(0,n.jsx)(t.h2,{id:"access-control-lists-acls",children:"Access Control Lists (ACLs)"}),"\n",(0,n.jsx)(t.p,{children:"OpenIX applies ACLs on the fabric to drop known illegitimate traffic types (e.g., STP BPDUs, LACP packets, IPv6 Router Advertisements that are rogue, etc.). We also filter DHCP server responses on the peering VLAN (to prevent any rogue DHCP). Essentially, any traffic that is not explicitly allowed (as defined in the technical policy) is filtered by default. This reduces the attack surface and chances of operational errors spreading."}),"\n",(0,n.jsx)(t.h2,{id:"route-server-security",children:"Route Server Security"}),"\n",(0,n.jsx)(t.p,{children:"The route servers themselves have stringent controls. They do not forward traffic, and they implement filters to ensure one participant cannot impersonate another at the BGP level. They also have prefix limits per peer and deny lists for bogon prefixes."}),"\n",(0,n.jsxs)(t.p,{children:["The route servers are configured to ",(0,n.jsx)(t.strong,{children:"never"})," forward a next-hop that isn\u2019t the originator (meaning they preserve the original BGP next hop of the route, which ensures that traffic from one participant to another goes directly, not through the route server). This way, even if compromised (which is highly unlikely with our security), a route server couldn\u2019t man-in-the-middle traffic \u2013 it\u2019s simply not in the forwarding path."]}),"\n",(0,n.jsx)(t.p,{children:"Additionally, the route servers are secured with MD5 passwords on BGP sessions if the participant requests (optional but available), and they run on hardened systems (limited access, regularly patched software, etc.)."}),"\n",(0,n.jsx)(t.h2,{id:"monitoring-and-anomaly-detection",children:"Monitoring and Anomaly Detection"}),"\n",(0,n.jsx)(t.p,{children:"OpenIX NOC monitors for unusual patterns, such as traffic spikes that might indicate a DDoS attack passing through the exchange, or a sudden drop in route server session count that might indicate a problem. We also look for health indicators such as CPU spikes on switches (which could indicate a L2 loop or broadcast storm)."}),"\n",(0,n.jsx)(t.p,{children:"If an anomaly is detected, staff investigate immediately. In case of something like a DDoS attack where one participant is the target and others could be collaterally affected, OpenIX may implement filters or blackholing for the target prefix upon request to mitigate impact (if the participant supports it, e.g., by advertising a BGP blackhole route with a special community to the route server, which OpenIX can then enforce by filtering that traffic)."}),"\n",(0,n.jsx)(t.p,{children:"OpenIX\u2019s policy is to protect the exchange as a whole; if necessary, we will temporarily isolate a participant that is overwhelming the fabric, while informing them, to preserve overall stability."})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},8453:(e,t,i)=>{i.d(t,{R:()=>o,x:()=>a});var r=i(6540);const n={},s=r.createContext(n);function o(e){const t=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);