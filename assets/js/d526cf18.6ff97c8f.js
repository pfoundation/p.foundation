"use strict";(self.webpackChunkp_foundation=self.webpackChunkp_foundation||[]).push([[5817],{2881:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>p});var r=n(5893),i=n(1151),a=n(7661);const s={id:"peering",title:"Peering Policy",description:"The policies governing traffic exchange, BGP sessions, and multilateral and bilateral peering arrangements at OpenIX."},o=void 0,l={id:"peering/peering",title:"Peering Policy",description:"The policies governing traffic exchange, BGP sessions, and multilateral and bilateral peering arrangements at OpenIX.",source:"@site/OpenIX/04-peering/index.md",sourceDirName:"04-peering",slug:"/peering/",permalink:"/OpenIX/peering/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{id:"peering",title:"Peering Policy",description:"The policies governing traffic exchange, BGP sessions, and multilateral and bilateral peering arrangements at OpenIX."},sidebar:"defaultSidebar",previous:{title:"Technical Standards",permalink:"/OpenIX/technicalStandards"},next:{title:"Etiquette",permalink:"/OpenIX/peering/etiquette"}},c={},p=[{value:"BGP Sessions",id:"bgp-sessions",level:2},{value:"Multilateral Peering",id:"multilateral-peering",level:2},{value:"Bilateral Peering",id:"bilateral-peering",level:2}];function u(e){const t={h2:"h2",p:"p",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"OpenIX\u2019s core purpose is to facilitate peering among networks. Peering is the mutual exchange of routing information and traffic between participants\u2019 networks. OpenIX itself does not involve itself in participants\u2019 business arrangements (most peering at OpenIX is settlement-free, but any commercial terms between networks are outside the scope of OpenIX)."}),"\n",(0,r.jsx)(t.p,{children:"To ensure an effective peering environment, the following policies apply:"}),"\n",(0,r.jsx)(t.h2,{id:"bgp-sessions",children:"BGP Sessions"}),"\n",(0,r.jsx)(t.p,{children:"All traffic exchange between participants across the IX is predicated on BGP. Participants must establish BGP sessions with each other (bilaterally or via the route servers) to exchange routes. OpenIX does not provide any transit or default routing \u2013 if there is no BGP route learned for a destination, traffic will not be exchanged."}),"\n",(0,r.jsx)(t.p,{children:"Participants are expected to only send traffic to destinations (prefixes) they have learned via BGP from that peer at the exchange. In other words, no static routes or proxy routing across the IX: the exchange is strictly for BGP-learned peering routes."}),"\n",(0,r.jsx)(t.h2,{id:"multilateral-peering",children:"Multilateral Peering"}),"\n",(0,r.jsx)(t.p,{children:"OpenIX offers route server service to simplify peering for participants. By peering with the route servers, a network can exchange routes with many other route-server-connected participants through a single (or dual for redundancy) BGP session, rather than maintaining individual sessions with each peer. Use of the route servers is optional but encouraged, especially for new or smaller participants to quickly gain reachability with others."}),"\n",(0,r.jsx)(t.p,{children:"Participants can still establish direct bilateral BGP sessions with any other participant if they choose (for example, if they prefer not to use the route server for certain peers or in general). OpenIX\u2019s route servers implement prefix filtering (using IRR and RPKI data to allow only valid, registered routes) and do not propagate routes learned from one participant to another if those routes are filtered or if the participant is not authorized to advertise them."}),"\n",(0,r.jsx)(t.p,{children:"The route servers also support community controls \u2013 participants can tag routes with BGP communities to control which peers receive them (e.g., to opt-out of peering with specific ASNs or to limit route distribution). These community conventions are documentted under the Route Servers section."}),"\n",(0,r.jsx)(t.h2,{id:"bilateral-peering",children:"Bilateral Peering"}),"\n",(0,r.jsx)(t.p,{children:"Participants are free to negotiate bilateral peering sessions with each other outside of the route server. OpenIX can provide assistance (such as listing all participant NOC contacts and PeeringDB info) but does not mandate any network to peer with any other \u2013 peering agreements are at the discretion of the participants."}),"\n",(0,r.jsx)(t.p,{children:"If a participant has a selective peering policy (e.g., only peers with certain types of networks or requires a certain traffic ratio), it is that participant\u2019s responsibility to communicate and enforce it."}),"\n",(0,r.jsx)(t.p,{children:"OpenIX itself will not enforce any bilateral peering requirements, aside from the expectation that participants should actively use the exchange for traffic exchange rather than remain idle."}),"\n",(0,r.jsx)(a.Z,{})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},7661:(e,t,n)=>{n.d(t,{Z:()=>v});n(7294);var r=n(6905),i=n(3734),a=n(4791),s=n(3777),o=n(2735),l=n(7325),c=n(3899);const p={cardContainer:"cardContainer_fWXF",cardTitle:"cardTitle_rnsV",cardDescription:"cardDescription_PWke"};var u=n(5893);function d(e){let{href:t,children:n}=e;return(0,u.jsx)(a.Z,{href:t,className:(0,r.Z)("card padding--lg",p.cardContainer),children:n})}function h(e){let{href:t,icon:n,title:i,description:a}=e;return(0,u.jsxs)(d,{href:t,children:[(0,u.jsxs)(c.Z,{as:"h2",className:(0,r.Z)("text--truncate",p.cardTitle),title:i,children:[n," ",i]}),a&&(0,u.jsx)("p",{className:(0,r.Z)("text--truncate",p.cardDescription),title:a,children:a})]})}function f(e){let{item:t}=e;const n=(0,i.LM)(t),r=function(){const{selectMessage:e}=(0,s.c)();return t=>e(t,(0,l.I)({message:"{count} items",id:"theme.docs.DocCard.categoryDescription.plurals",description:"The default description for a category card in the generated index about how many items this category includes"},{count:t}))}();return n?(0,u.jsx)(h,{href:n,icon:"\ud83d\uddc3\ufe0f",title:t.label,description:t.description??r(t.items.length)}):null}function g(e){let{item:t}=e;const n=(0,o.Z)(t.href)?"\ud83d\udcc4\ufe0f":"\ud83d\udd17",r=(0,i.xz)(t.docId??void 0);return(0,u.jsx)(h,{href:t.href,icon:n,title:t.label,description:t.description??r?.description})}function m(e){let{item:t}=e;switch(t.type){case"link":return(0,u.jsx)(g,{item:t});case"category":return(0,u.jsx)(f,{item:t});default:throw new Error(`unknown item type ${JSON.stringify(t)}`)}}function x(e){let{className:t}=e;const n=(0,i.jA)();return(0,u.jsx)(v,{items:n.items,className:t})}function v(e){const{items:t,className:n}=e;if(!t)return(0,u.jsx)(x,{...e});const a=(0,i.MN)(t);return(0,u.jsx)("section",{className:(0,r.Z)("row",n),children:a.map(((e,t)=>(0,u.jsx)("article",{className:"col col--6 margin-bottom--lg",children:(0,u.jsx)(m,{item:e})},t)))})}},3777:(e,t,n)=>{n.d(t,{c:()=>c});var r=n(7294),i=n(9962);const a=["zero","one","two","few","many","other"];function s(e){return a.filter((t=>e.includes(t)))}const o={locale:"en",pluralForms:s(["one","other"]),select:e=>1===e?"one":"other"};function l(){const{i18n:{currentLocale:e}}=(0,i.Z)();return(0,r.useMemo)((()=>{try{return function(e){const t=new Intl.PluralRules(e);return{locale:e,pluralForms:s(t.resolvedOptions().pluralCategories),select:e=>t.select(e)}}(e)}catch(t){return console.error(`Failed to use Intl.PluralRules for locale "${e}".\nDocusaurus will fallback to the default (English) implementation.\nError: ${t.message}\n`),o}}),[e])}function c(){const e=l();return{selectMessage:(t,n)=>function(e,t,n){const r=e.split("|");if(1===r.length)return r[0];r.length>n.pluralForms.length&&console.error(`For locale=${n.locale}, a maximum of ${n.pluralForms.length} plural forms are expected (${n.pluralForms.join(",")}), but the message contains ${r.length}: ${e}`);const i=n.select(t),a=n.pluralForms.indexOf(i);return r[Math.min(a,r.length-1)]}(n,t,e)}}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var r=n(7294);const i={},a=r.createContext(i);function s(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);